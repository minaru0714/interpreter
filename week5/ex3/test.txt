let rec loop x = loop x;;

    => loop : t1 -> t2

let head = fun x ->
  match x with
    h :: t -> h
  | [] -> 0
  end;;
in
head (5 :: loop ());;

let z = loop ();;

    => z : t2
loop ();;

    => 止まらない
    let rec loop x = loop x;;
(fun x -> 42) (loop ());;

    => - : Int = 42;;
(fun x -> fun y -> x) 5 (loop ());;

    => - : Int = 5
    let rec loop x = loop x;;
(fun x -> fun y -> x) (loop ()) 5;;

    => 止まらない

let rec loop = loop;;
    => loop : t1


let rec loop = loop in loop;;
    => 止まらない


let rec fix = fun f -> f (fix f) in
fix (fun f -> fun x -> if x < 1 then 1 else x * f (x - 1));;
    => - : Int -> Int = <fun>


let rec take n = fun l ->
  if n < 1 then
    []
  else
    match l with
      h :: t -> h :: take (n - 1) t
    | _ -> []
    end
in
let rec mylist = 0 :: 1 :: mylist in
take 5 mylist;;
    => - : [Int] = [0,1,0,1,0]


    let rec loop x = loop x;;


let z = loop ();;


(fun x -> 42) (loop ())


(fun x -> fun y -> x) 5 (loop ());;



  (*| CLetRec fs ->
          let inferred_types_with_envs = List.map (fun (var, exp) -> (var, infer_expr ty_env exp)) fs in
          let new_ty_env = List.fold_left (fun env (var, (ty, _)) -> (var, ty) :: env) ty_env inferred_types_with_envs in
          let new_eval_env = List.map (fun (var, exp) -> (var, Thunk(exp, eval_env))) fs in
          loop (new_ty_env, new_eval_env @ eval_env)
        
v**)
